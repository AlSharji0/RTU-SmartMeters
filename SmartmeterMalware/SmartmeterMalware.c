#include <Windows.h>
#include <stdio.h>


HANDLE GetSerialHandle(const wchar_t* port_name){
	HANDLE hSerial = CreateFileW(port_name, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hSerial == INVALID_HANDLE_VALUE) {
		printf("Failed to get Serial Handle. Error: %ld\n", GetLastError());
		CloseHandle(hSerial);
		return INVALID_HANDLE_VALUE;
	}
	
	DCB DcbSerialParams = { 0 };
	COMMTIMEOUTS timeouts = { 0 };

	if (!GetCommState(hSerial, &DcbSerialParams)) {
		printf("Failed to get comm state.");
		CloseHandle(hSerial);
		return INVALID_HANDLE_VALUE;
	}

	//Configurations
	DcbSerialParams.DCBlength = sizeof(DCB);
	DcbSerialParams.BaudRate = CBR_9600;
	DcbSerialParams.ByteSize = 8;
	DcbSerialParams.Parity = NOPARITY;
	DcbSerialParams.StopBits = ONESTOPBIT;

	timeouts.ReadIntervalTimeout = 50;
	timeouts.ReadTotalTimeoutConstant = 50;
	timeouts.ReadTotalTimeoutMultiplier = 10; //Should keep it from inf looping if slave doesn't respond.
	timeouts.WriteTotalTimeoutConstant = 50; //Same here.
	timeouts.WriteTotalTimeoutMultiplier = 10;

	if (!SetCommState(hSerial, &DcbSerialParams)) {
		printf("Failed to set comm state. Error: %ld\n", GetLastError());
		CloseHandle(hSerial);
		return INVALID_HANDLE_VALUE;
	}

	if (!SetCommTimeouts(hSerial, &timeouts)) {
		printf("Failed to set comm timeouts. Error: %ld\n", GetLastError());
		CloseHandle(hSerial);
		return INVALID_HANDLE_VALUE;
	}

	return hSerial;
}

unsigned short CRC16(const unsigned char* buffer, int length) {
	unsigned short crc = 0xFFFF;

	for (int i = 0; i < length; i++) {
		crc ^= (unsigned short)buffer[i];

		for (int j = 0; j < 8; j++) {
			if ((crc & 0x0001) != 0) {
				crc >>= 1;
				crc ^= 0xA001;
			} 
			else {
				crc >>= 1;
			}
		}
	}

	return crc;
}

void manipulate(unsigned char* response, int length) {
	for (int i = 0; i < length; i++) {
		response[i] = (unsigned char)(response[i] * 0.6);
	}
}

int main() {
	const wchar_t* portname = L"COM3"; //Whatever the slave port ends up being.
	unsigned char modbus_frame[8] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02 }; //slave id, func code, starting address, no of registers, CRC
	unsigned char buffer[256];	                                      //    0    ,     1    ,      2 - 3      ,      4 - 5     ,   6 - 7
	DWORD bytes_written, bytes_read;

	HANDLE hSerial = GetSerialHandle(portname);
	if (hSerial == INVALID_HANDLE_VALUE) return -1;
	
	unsigned short crc = CRC16(modbus_frame, 6);
	modbus_frame[6] = crc & 0xFF;
	modbus_frame[7] = (crc >> 8) & 0xFF;

	while (TRUE) {
		if (!ReadFile(hSerial, buffer, 256, &bytes_read, NULL)) {
			printf("Failed to read from slave. Error: %ld\n", GetLastError());
			break;
		}

		manipulate(buffer, bytes_read);

		modbus_frame[1] = 0x10; //0x10 is the write func code

		if (!WriteFile(hSerial, modbus_frame, 8, &bytes_written, NULL)) {
			printf("Failed to write modbus frame. Error: %ld\n", GetLastError());
			break;
		}

		Sleep(1000); //To avoid stunning the device
	}

	CloseHandle(hSerial);
	return 0;
}
